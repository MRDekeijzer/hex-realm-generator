import type { Point, Hex, HexOrientation } from '../types';

export function axialToPixel(hex: { q: number; r: number }, orientation: HexOrientation, size: Point): Point {
  let x, y;
  if (orientation === 'pointy') {
    x = size.x * (Math.sqrt(3) * hex.q + Math.sqrt(3) / 2 * hex.r);
    y = size.y * (3. / 2 * hex.r);
  } else { // flat
    x = size.x * (3. / 2 * hex.q);
    y = size.y * (Math.sqrt(3) / 2 * hex.q + Math.sqrt(3) * hex.r);
  }
  return { x, y };
}

export function getHexCorners(orientation: HexOrientation, size: Point, scale = 1): Point[] {
    const corners: Point[] = [];
    for (let i = 0; i < 6; i++) {
        let angle;
        // For pointy-top, corners are calculated clockwise starting from the top-right corner (-30 degrees)
        // This ensures the hex is drawn with a flat top and bottom, which is standard for "pointy-top" axial systems.
        if (orientation === 'pointy') {
            angle = Math.PI / 180 * (60 * i - 30);
        } else { // flat
            // For flat-top, start at 0 degrees.
            angle = Math.PI / 180 * (60 * i);
        }
        corners.push({
            x: size.x * Math.cos(angle) * scale,
            y: size.y * Math.sin(angle) * scale,
        });
    }
    return corners;
}

export function getBarrierPath(edgeIndex: number, corners: Point[]): string {
    const start = corners[edgeIndex];
    const end = corners[(edgeIndex + 1) % 6];
    return `M ${start.x} ${start.y} L ${end.x} ${end.y}`;
}

// Function to find the closest edge to a point within a hex's local coordinate system.
// The point is relative to the hex center (0,0).
export function findClosestEdge(point: Point, corners: Point[]): number {
    let minDistance = Infinity;
    let closestEdgeIndex = -1;

    for (let i = 0; i < 6; i++) {
        const p1 = corners[i];
        const p2 = corners[(i + 1) % 6];

        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;

        if (dx === 0 && dy === 0) { // Should not happen for a hex
            const dist = Math.sqrt(Math.pow(point.x - p1.x, 2) + Math.pow(point.y - p1.y, 2));
            if (dist < minDistance) {
                minDistance = dist;
                closestEdgeIndex = i;
            }
            continue;
        }

        const t = ((point.x - p1.x) * dx + (point.y - p1.y) * dy) / (dx * dx + dy * dy);

        let closestX, closestY;
        if (t < 0) {
            closestX = p1.x;
            closestY = p1.y;
        } else if (t > 1) {
            closestX = p2.x;
            closestY = p2.y;
        } else {
            closestX = p1.x + t * dx;
            closestY = p1.y + t * dy;
        }
        
        const distance = Math.sqrt(Math.pow(point.x - closestX, 2) + Math.pow(point.y - closestY, 2));

        if (distance < minDistance) {
            minDistance = distance;
            closestEdgeIndex = i;
        }
    }
    return closestEdgeIndex;
}


// This array MUST be ordered to match the edge indices generated by getHexCorners.
// For pointy-top hexes (with the first corner at -30 degrees), the edge indices correspond to:
// 0: Right (E)
// 1: Bottom-Right (SE)
// 2: Bottom-Left (SW)
// 3: Left (W)
// 4: Top-Left (NW)
// 5: Top-Right (NE)
const axialDirections = [
    { q: +1, r: 0 },    // 0: E
    { q: 0, r: +1 },    // 1: SE
    { q: -1, r: +1 },   // 2: SW
    { q: -1, r: 0 },    // 3: W
    { q: 0, r: -1 },    // 4: NW
    { q: +1, r: -1 }    // 5: NE
];

export function getNeighbors(hex: { q: number, r: number }): { q: number, r: number }[] {
    return axialDirections.map(dir => ({
        q: hex.q + dir.q,
        r: hex.r + dir.r,
    }));
}

export function getAxialDistance(a: {q: number, r: number}, b: {q: number, r: number}): number {
    const dq = Math.abs(a.q - b.q);
    const dr = Math.abs(a.r - b.r);
    const ds = Math.abs((-a.q - a.r) - (-b.q - b.r));
    return (dq + dr + ds) / 2;
}